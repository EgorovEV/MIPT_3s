#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <algorithm>
#include <queue>

using std::cout;
using std::cin;
using std::vector;
using std::string;
using std::min;
using std::abs;
using std::queue;

//std::ifstream file("input.txt");

int FindPath(vector<vector<int> > &gr, vector<vector<int> > &f, int source, int target, int edges_count, int vertex_count) {
	queue<int> q;
	q.push(source);
	vector<int> way(vertex_count);
	way[target] = -1; // особая метка для стока
	int i;
	int CurVertex;
	vector<int> Flow;
	Flow.assign(vertex_count, 0);
	Flow[source] = 1001;
	while (way[target] == -1 && !q.empty())
	{
		CurVertex = q.front();
		q.pop();
		for (i = 0; i < vertex_count; i++)
			if ((gr[CurVertex][i] - f[CurVertex][i]) > 0 && Flow[i] == 0)
			{
				//cout << "sp cout=" << gr[CurVertex][i] - f[CurVertex][i] << '\n';
				q.push(i);
				way[i] = CurVertex; // указываем, что в i добрались из CurVertex
									// и находим значение потока текущее через вершину i
				if (gr[CurVertex][i] - f[CurVertex][i] < Flow[CurVertex])
					Flow[i] = (gr[CurVertex][i] - f[CurVertex][i]);
				else
					Flow[i] = Flow[CurVertex];
			}
	}
	// закончив поиск пути
	if (way[target] == -1) return 0;
	CurVertex = target;
	while (CurVertex != source) // путь из стока в исток мы восстанавливаем с помощбю массива way
	{
		//cout << f[way[CurVertex]][CurVertex] << "=f min_flow= " << Flow[target] << '\n';
		f[way[CurVertex]][CurVertex] += Flow[target];
		f[CurVertex][way[CurVertex]] -= Flow[target];
		CurVertex = way[CurVertex];
	}

	//for (int i = 0; i < gr.size(); ++i) {
	//	for (int j = 0; j < gr[i].size(); ++j) {
	//		cout << gr[i][j] - f[i][j] << " ";
	//		//cout << "flow " << gr[i][j] << "from " << i << "to " << j << "\n";
	//	}
	//	cout << '\n';
	//}
	//cout << '\n';

	return Flow[target];
}

void dfs(vector<vector<int> > &gr, vector<bool> &visited, int vertex_count, int s) {
	queue<int> q;
	q.push(s);

	visited.assign(vertex_count, false);
	visited[s] = true;
	int CurVertex;

	while (!q.empty())
	{
		CurVertex = q.front();
		q.pop();
		for (int i = 0; i < vertex_count; i++)
			if (gr[CurVertex][i] > 0 && visited[i] == false)
			{
				q.push(i);
				visited[i] = true;
			}
	}
}

int search_max_flow(vector<vector<int> > &gr, int source, int target, int edges_count, int vertex_count, vector<vector<int> > &f) {
	
	int MaxFlow = 0;
	int AddFlow;
	do
	{
		AddFlow = FindPath(gr, f, source, target, edges_count, vertex_count);
		//cout << ' ' << AddFlow << '\n';
		MaxFlow += AddFlow;
	} while (AddFlow > 0);


	//for (int i = 0; i < vertex_count; ++i) {
	//	for (int j = 0;j < vertex_count; ++j)
	//		cout << c[i][j] << ' ';
	//	cout << std::endl;
	//}
	//cout << "max flow= " << MaxFlow << std::endl;
	return MaxFlow;
}



void repair_str(string &str, string &pattern) {
	int missed_str = 0, missed_pat = 0;
	for (auto i : str)
		if (i == '?')
			++missed_str;
	for (auto i : pattern)
		if (i == '?')
			++missed_pat;
	int graph_size = missed_pat + missed_str + 1 + 1;
	vector<vector<int>> graph(graph_size);
	for (size_t i = 0; i < graph_size; ++i)
		graph[i].assign(graph_size, 0);

	int haf_dist = 0;
	int q_in_str = 1;
	int q_in_pattern = (missed_str) + 1;
	bool find_q = false;
	int bottom_edge = (int)(str.size() - pattern.size());

	for (size_t i = 0; i < str.size(); ++i) {
		for (size_t j = 0; j < min(pattern.size(), i + 1); ++j) {	//Усливие с min- чтобы обрезать перебор вначале
			if (i > bottom_edge + j) {	//чтобы не перебирать весь щаблон вконце
				/*cout << "i = " << i << " bottom_edege= " << bottom_edge << "j = " << j << ' ';
				if (pattern[j] == '?') {
					++q_in_pattern;
					continue;
				}
				if (str[i] != pattern[j] && ) {
					haf_dist++;
					cout << "FUCK!";
					cout << "haf_dis= " << haf_dist << ' ' << i << ' ' << j;
					cout << "str[i]= "  << str[i] << "pat[j]= " << pattern[j] << std::endl;
				}*/
				continue;
			}
			//Далее: если в строке и шакблоне при сравнивании стоят
			if (str[i] == '?' && pattern[j] == '?') {	
				find_q = true;
				graph[q_in_str][q_in_pattern] += 1;
				graph[q_in_pattern++][q_in_str] += 1;

				continue;
			}
			if (str[i] == '?') {
				find_q = true;
				if (pattern[j] == '0')
					graph[0][q_in_str] += 1;
				else
					graph[q_in_str][graph_size - 1] += 1;
				continue;
			}
			if (pattern[j] == '?') {
				if (str[i] == '0')
					graph[0][q_in_pattern++] += 1;
				else
					graph[q_in_pattern++][graph_size - 1] += 1;
				continue;
			}

			if (str[i] != pattern[j]) {
				haf_dist++;
				//cout << "haf_dis(norm)= " << haf_dist << ' ' << i << ' ' << j << std::endl;
			}
		}
		q_in_pattern = missed_str + 1;
		if (find_q == true) {
			++q_in_str;
			find_q = false;
		}
	}
	
	//for (int i = 0; i < graph.size(); ++i) {
	//	for (auto j : graph[i])
	//		cout << j << " ";
	//	cout << std::endl;
	//}

	vector<vector<int>> f(graph_size);	//поток
	for (int i = 0; i < graph_size; ++i) {
		f[i].assign(graph_size, 0);
	}

	int flow = search_max_flow(graph, 0, graph_size - 1, 0, graph_size, f);

	vector<bool> visited;

	vector<vector<int> > c(graph_size);
	for (int i = 0; i < graph_size;++i) {
		c[i].assign(graph_size, 0);
		for (int j = 0; j < graph_size; ++j) {
			c[i][j] = graph[i][j] - f[i][j];
		}
	}

	dfs(c, visited, graph_size, 0);

	size_t pointer = 1;
	for (size_t i = 0; i < str.size(); ++i) {
		if (str[i] == '?') {
			if (visited[pointer] == true)
				str[i] = '0';
			else {
				str[i] = '1';
			}
			++pointer;
		}
	}
	for (size_t i = 0; i < pattern.size(); ++i)
		if (pattern[i] == '?') {
			if (visited[pointer] == true)
				pattern[i] = '0';
			else
				pattern[i] = '1';
			++pointer;
		}
	//cout << "ANSWER: " << flow + haf_dist << std::endl;
	cout << flow + haf_dist << std::endl;
	//cout << "haf_dis" << haf_dist << std::endl;
}

int main() {
	string str, pattern;
	cin >> str >> pattern;
	//file >> str >> pattern;
	repair_str(str, pattern);
	cout << str << std::endl << pattern << std::endl;
	return 0;
}
