		В решении использован алгоритм Флойда-Уоршелла.
0) Изначально есть граф- представленный матрицей смежности
(храниться в векторе (n*n) элементов)

Описание алгоритма:
Идея- разбить процесс поиска мин. путей на итерации
Максимум n итераций;
*) Перед k-ой фазой величина d[i][j] равна длине кратчайшего пути из вершины i в вершину j
*) Это свойство выполнено для первой фазы, т.к в матрицу расстояний d[][] записанна матрица смежности графа: d[i][j] = g[i][j] — стоимости ребра из вершины i в вершину j.
*) При выяснении мин. пути будут 2 случ:
  1) Крат. путь проходит из вершины i в вершину j,   через вершины { 1, 2... k },
    и совпадает с кратчайшим путём, которому разрешено проходить через вершины множества { 1, 2...k-1}
  2)"Новый"(через k вершин) кратчайший путь стал лучше "старого"(k-1) пути. => 
    => "новый" кратчайший путь проходит через вершину k. 
Тогда заметим, что если мы разобьём этот "новый" путь вершиной k на две половинки (одна i ->k, вторая — k ->j), то каждая из этих половинок уже не заходит в вершину k. Но тогда получается, что длина каждой из этих половинок была посчитана ещё на k-1-ой фазе или ещё раньше, и нам достаточно взять просто сумму d[i][k] + d[k][j], она и даст длину "нового" кратчайшего пути.
=> ищем мин. путь из этих 2-ч случаев.
d[i][j] = min(d[i][j] , d[i][k] + d[k][j]) где k-номер итерации.

Сложность:
время: 3 цикла от 0 до n => n^3
память: матрица смежности n*n => n^2
