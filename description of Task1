	                При решении использован алгоритм Беллмана-Форда.
*)Описание алгоритма, применного в первой версии (ветка feature.-task1) программы:
    Заведем массив d[0 .. n-1], в котором будут записываться рассояния до вершин,
    и содержащий ответ на задачу после зав. работы алгоритма. В начале работы мы заполняем его так:
    расст. самой вершины до себя=0 => d[v] = 0, а все остальные элементы d[] равны бесконечности(расст. ещё не определено). 
    Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе просматриваются все рёбра графа,
    и алгоритм пытается произвести релаксацию  вдоль каждого ребра (a,b) стоимости < inf ,
    т.е. мы пытаемся улучшить ответ для вершины b, пользуясь ребром (a,b) и текущим ответом для вершины a.
    
    Утверждается, что достаточно n-1 фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе.
    Для недостижимых вершин расстояние d[] останется равным бесконечности.
    
*)Улучшение, примененное во 2 версии
    Иногда алг. находит реш. <, чем за n-1 действие. Поэтому если на какой-то фазе ничего не произошло,
    то алгоритм можно останавливать. (Эта оптимизация не улучшает асимптотику,
    т.е. на некоторых графах по-прежнему будут нужны все n-1 фаза, но значительно ускоряет поведение алгоритма "в среднем",
    т.е. на случайных графах.)
    С такой оптимизацией становится вообще ненужным ограничивать вручную число фаз алгоритма числом n-1
    --он сам остановится через нужное число фаз.
*) Док-во корректности:	
    1)Для недостижимых из v вершин алгоритм отработает корректно: для них d[] = равной бесконечности
    (т.к. алгоритм Форда-Беллмана найдёт какие-то пути до всех достижимых из s вершин,
    а релаксация во всех остальных вершинах не произойдёт ни разу).
  УТВЕРЖДЕНИЕ
    После выполнения i фаз алгоритм Форда-Беллмана корректно находит все кратчайшие пути, 
    длина которых (по числу рёбер) не превосходит i. Т.е. после k фаз  кратчайший путь, содерж. k ребер будет найден гарантированно.
    
    Доказательство. Рассмотрим произвольную вершину a, до которой существует путь из стартовой вершины v,
    и рассмотрим кратчайший путь до неё: (p0=v, p1, ..., pk=a). Перед первой фазой кратчайший путь до вершины p0=v найден корректно.
    Во время первой фазы ребро (p0,p1) было просмотрено алгоритмом Форда-Беллмана, следовательно,
    расстояние до вершины p1 было корректно посчитано после первой фазы. Повторяя эти утверждения k раз, получаем,
    что после k-й фазы расстояние до вершины p1k=a посчитано корректно, что и требовалось доказать.
    Последнее, что надо заметить — это то, что любой кратчайший путь не может иметь более n-1 ребра.
    Следовательно, алгоритму достаточно произвести только n-1 фазу. 
    
*) Логика программы: 
    алгоритм Б-Ф изменить так, чтобы он искал наидлиннейший путь до вершины- т.е. наибольшую выгоду по обмену.
    При этом, если в задаче присутствует арбитраж(цикл, где знач. расст. до вершин увелич. с каждым обходом),
    то алгорим зациклится. => не остановиться через n-1 операцию.
*) Изменения алг. для арбитража.
	1)  "+" -> "*"  Из условия: операция обмена по курсу  "1:x" означает " _ * х"
	2)Нач. эл-т "0" заменяется на "1" - нейтр. эл-т по умнженю
	3)Переделать на поиск макс. длинны пути.( заменить в сравнении предикат)
